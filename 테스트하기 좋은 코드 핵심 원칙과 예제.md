# 테스트하기 좋은 코드 핵심 원칙과 예제

## 1. 의존성 주입 (Dependency Injection)

**핵심**: 내부에서 의존성을 직접 생성하지 않고 외부에서 주입받기

**나쁜 예제**:
```java
public class OrderService {
    private final EmailSender emailSender = new EmailSender();
    
    public void processOrder(Order order) {
        // 주문 처리 로직
        emailSender.sendConfirmation(order);
    }
}
```

**좋은 예제**:
```java
public class OrderService {
    private final EmailSender emailSender;
    
    public OrderService(EmailSender emailSender) {
        this.emailSender = emailSender;
    }
    
    public void processOrder(Order order) {
        // 주문 처리 로직
        emailSender.sendConfirmation(order);
    }
}
```

## 2. 인터페이스를 통한 느슨한 결합 (Loose Coupling)

**핵심**: 구체 클래스 대신 인터페이스에 의존하기

**나쁜 예제**:
```java
public class PaymentProcessor {
    private final PayPalGateway paymentGateway = new PayPalGateway();
    
    public Receipt processPayment(Payment payment) {
        return paymentGateway.charge(payment);
    }
}
```

**좋은 예제**:
```java
public class PaymentProcessor {
    private final PaymentGateway paymentGateway;
    
    public PaymentProcessor(PaymentGateway paymentGateway) {
        this.paymentGateway = paymentGateway;
    }
    
    public Receipt processPayment(Payment payment) {
        return paymentGateway.charge(payment);
    }
}
```

## 3. 순수 함수 (Pure Functions)

**핵심**: 동일 입력에 항상 동일 출력을 보장하는 함수 작성

**나쁜 예제**:
```java
public class TaxCalculator {
    private double taxRate;
    
    public double calculateTax(double amount) {
        taxRate = TaxRateService.getCurrentRate(); // 외부 상태에 의존
        return amount * taxRate;
    }
}
```

**좋은 예제**:
```java
public class TaxCalculator {
    public double calculateTax(double amount, double taxRate) {
        return amount * taxRate;
    }
}
```

## 4. 작은 메소드와 단일 책임 (Small Methods, Single Responsibility)

**핵심**: 각 메소드가 한 가지 작업만 수행하도록 설계

**나쁜 예제**:
```java
public void processUserRegistration(User user) {
    // 유효성 검증
    if (user.getName() == null || user.getEmail() == null) {
        throw new ValidationException("Invalid user data");
    }
    
    // DB에 저장
    userRepository.save(user);
    
    // 이메일 발송
    EmailSender sender = new EmailSender();
    sender.sendWelcomeEmail(user.getEmail());
    
    // 로그 기록
    logger.info("User registered: " + user.getEmail());
}
```

**좋은 예제**:
```java
public void processUserRegistration(User user) {
    validateUser(user);
    User savedUser = saveUser(user);
    notifyUser(savedUser);
    logRegistration(savedUser);
}

private void validateUser(User user) {
    if (user.getName() == null || user.getEmail() == null) {
        throw new ValidationException("Invalid user data");
    }
}

private User saveUser(User user) {
    return userRepository.save(user);
}

private void notifyUser(User user) {
    emailService.sendWelcomeEmail(user.getEmail());
}

private void logRegistration(User user) {
    logger.info("User registered: " + user.getEmail());
}
```

## 5. 관심사 분리 (Separation of Concerns)

**핵심**: 비즈니스 로직과 인프라 코드(DB, 외부 API 등)를 분리

**나쁜 예제**:
```java
public class UserService {
    public User getUserDetails(long userId) {
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/users");
        PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users WHERE id = ?");
        stmt.setLong(1, userId);
        ResultSet rs = stmt.executeQuery();
        
        // ResultSet에서 User 객체로 변환하는 코드...
        
        return user;
    }
}
```

**좋은 예제**:
```java
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User getUserDetails(long userId) {
        return userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException(userId));
    }
}
```

## 6. 테스트 가능한 설계 예제

**비즈니스 규칙 테스트**:
```java
public class PricingService {
    public double calculateDiscount(Order order, Customer customer) {
        double discount = 0;
        
        // VIP 고객이면 10% 할인
        if (customer.isVip()) {
            discount += 0.1;
        }
        
        // 주문 금액이 10만원 이상이면 5% 추가 할인
        if (order.getTotalAmount() >= 100000) {
            discount += 0.05;
        }
        
        // 최대 할인은 20%
        return Math.min(discount, 0.2);
    }
}

// 테스트
@Test
void vipCustomerGets10PercentDiscount() {
    PricingService service = new PricingService();
    Customer vipCustomer = new Customer(true);  // VIP
    Order normalOrder = new Order(50000);      // 5만원
    
    double discount = service.calculateDiscount(normalOrder, vipCustomer);
    
    assertEquals(0.1, discount);
}
```

예제 코드에 캡슐화, 책임에 문제가 있음.
<details>
<summary>캡슐화 개선 코드</summary>

네, 좋은 지적입니다. 이 코드는 도메인 모델의 캡슐화와 책임 분리 원칙 측면에서 개선이 필요합니다.

현재 코드의 문제점:

1. `order.getTotalAmount()` 호출은 Order 객체의 내부 구현을 PricingService가 직접 알고 있어야 함
2. 할인 정책(10만원 이상 5% 할인)이 PricingService에 하드코딩되어 있음
3. 비즈니스 규칙이 도메인 객체가 아닌 서비스 계층에 구현되어 있음

개선된 버전은 다음과 같을 수 있습니다:

```java
public class Order {
    private List<OrderItem> items;
    private static final double LARGE_ORDER_THRESHOLD = 100000;
    
    // 기타 필드와 생성자...
    
    public double getTotalAmount() {
        return items.stream()
                .mapToDouble(OrderItem::getSubtotal)
                .sum();
    }
    
    public boolean isLargeOrder() {
        return getTotalAmount() >= LARGE_ORDER_THRESHOLD;
    }
    
    public double calculateOrderDiscount() {
        return isLargeOrder() ? 0.05 : 0;
    }
}

public class Customer {
    private CustomerTier tier;
    
    // 기타 필드와 생성자...
    
    public boolean isVip() {
        return tier == CustomerTier.VIP;
    }
    
    public double calculateCustomerDiscount() {
        return isVip() ? 0.1 : 0;
    }
}

public class PricingService {
    private static final double MAX_DISCOUNT = 0.2;
    
    public double calculateDiscount(Order order, Customer customer) {
        double orderDiscount = order.calculateOrderDiscount();
        double customerDiscount = customer.calculateCustomerDiscount();
        
        double totalDiscount = orderDiscount + customerDiscount;
        return Math.min(totalDiscount, MAX_DISCOUNT);
    }
}
```

이렇게 개선하면:

1. 각 도메인 객체가 자신의 상태와 관련된 규칙을 캡슐화함
2. Order는 자신이 '대량 주문'인지 판단하고 그에 따른 할인을 계산
3. Customer는 자신이 VIP인지 판단하고 그에 따른 할인을 계산
4. PricingService는 각 도메인에게 할인 계산을 위임하고 최종 할인율만 결정

이러한 접근 방식은 도메인 주도 설계(DDD)의 원칙과도 일치하며, 각 객체가 자신의 책임에 집중하게 됩니다. 또한 할인 정책이 변경되더라도 해당 도메인 객체만 수정하면 되므로 유지보수성이 향상됩니다.
</details>

## 7. 예외 처리 테스트

```java
public class AccountService {
    private final AccountRepository repository;
    
    public AccountService(AccountRepository repository) {
        this.repository = repository;
    }
    
    public void withdraw(String accountId, double amount) {
        Account account = repository.findById(accountId)
            .orElseThrow(() -> new AccountNotFoundException(accountId));
            
        if (amount <= 0) {
            throw new InvalidAmountException("Amount must be positive");
        }
        
        if (account.getBalance() < amount) {
            throw new InsufficientFundsException("Not enough funds");
        }
        
        account.withdraw(amount);
        repository.save(account);
    }
}

// 테스트
@Test
void throwsExceptionWhenAccountNotFound() {
    AccountRepository mockRepo = mock(AccountRepository.class);
    when(mockRepo.findById("non-existent")).thenReturn(Optional.empty());
    
    AccountService service = new AccountService(mockRepo);
    
    assertThrows(AccountNotFoundException.class, () -> {
        service.withdraw("non-existent", 100);
    });
}
```

이러한 원칙과 패턴을 적용하면 코드는 더 모듈화되고, 테스트하기 쉬워지며, 장기적으로 유지보수가 용이해집니다.
