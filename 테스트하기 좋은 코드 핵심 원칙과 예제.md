# 테스트하기 좋은 코드 핵심 원칙과 예제

## 1. 의존성 주입 (Dependency Injection)

**핵심**: 내부에서 의존성을 직접 생성하지 않고 외부에서 주입받기

**나쁜 예제**:
```java
public class OrderService {
    private final EmailSender emailSender = new EmailSender();
    
    public void processOrder(Order order) {
        // 주문 처리 로직
        emailSender.sendConfirmation(order);
    }
}
```

**좋은 예제**:
```java
public class OrderService {
    private final EmailSender emailSender;
    
    public OrderService(EmailSender emailSender) {
        this.emailSender = emailSender;
    }
    
    public void processOrder(Order order) {
        // 주문 처리 로직
        emailSender.sendConfirmation(order);
    }
}
```

## 2. 인터페이스를 통한 느슨한 결합 (Loose Coupling)

**핵심**: 구체 클래스 대신 인터페이스에 의존하기

**나쁜 예제**:
```java
public class PaymentProcessor {
    private final PayPalGateway paymentGateway = new PayPalGateway();
    
    public Receipt processPayment(Payment payment) {
        return paymentGateway.charge(payment);
    }
}
```

**좋은 예제**:
```java
public class PaymentProcessor {
    private final PaymentGateway paymentGateway;
    
    public PaymentProcessor(PaymentGateway paymentGateway) {
        this.paymentGateway = paymentGateway;
    }
    
    public Receipt processPayment(Payment payment) {
        return paymentGateway.charge(payment);
    }
}
```

## 3. 순수 함수 (Pure Functions)

**핵심**: 동일 입력에 항상 동일 출력을 보장하는 함수 작성

**나쁜 예제**:
```java
public class TaxCalculator {
    private double taxRate;
    
    public double calculateTax(double amount) {
        taxRate = TaxRateService.getCurrentRate(); // 외부 상태에 의존
        return amount * taxRate;
    }
}
```

**좋은 예제**:
```java
public class TaxCalculator {
    public double calculateTax(double amount, double taxRate) {
        return amount * taxRate;
    }
}
```

## 4. 작은 메소드와 단일 책임 (Small Methods, Single Responsibility)

**핵심**: 각 메소드가 한 가지 작업만 수행하도록 설계

**나쁜 예제**:
```java
public void processUserRegistration(User user) {
    // 유효성 검증
    if (user.getName() == null || user.getEmail() == null) {
        throw new ValidationException("Invalid user data");
    }
    
    // DB에 저장
    userRepository.save(user);
    
    // 이메일 발송
    EmailSender sender = new EmailSender();
    sender.sendWelcomeEmail(user.getEmail());
    
    // 로그 기록
    logger.info("User registered: " + user.getEmail());
}
```

**좋은 예제**:
```java
public void processUserRegistration(User user) {
    validateUser(user);
    User savedUser = saveUser(user);
    notifyUser(savedUser);
    logRegistration(savedUser);
}

private void validateUser(User user) {
    if (user.getName() == null || user.getEmail() == null) {
        throw new ValidationException("Invalid user data");
    }
}

private User saveUser(User user) {
    return userRepository.save(user);
}

private void notifyUser(User user) {
    emailService.sendWelcomeEmail(user.getEmail());
}

private void logRegistration(User user) {
    logger.info("User registered: " + user.getEmail());
}
```

## 5. 관심사 분리 (Separation of Concerns)

**핵심**: 비즈니스 로직과 인프라 코드(DB, 외부 API 등)를 분리

**나쁜 예제**:
```java
public class UserService {
    public User getUserDetails(long userId) {
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/users");
        PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users WHERE id = ?");
        stmt.setLong(1, userId);
        ResultSet rs = stmt.executeQuery();
        
        // ResultSet에서 User 객체로 변환하는 코드...
        
        return user;
    }
}
```

**좋은 예제**:
```java
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User getUserDetails(long userId) {
        return userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException(userId));
    }
}
```

## 6. 테스트 가능한 설계 예제

**비즈니스 규칙 테스트**:
```java
public class PricingService {
    public double calculateDiscount(Order order, Customer customer) {
        double discount = 0;
        
        // VIP 고객이면 10% 할인
        if (customer.isVip()) {
            discount += 0.1;
        }
        
        // 주문 금액이 10만원 이상이면 5% 추가 할인
        if (order.getTotalAmount() >= 100000) {
            discount += 0.05;
        }
        
        // 최대 할인은 20%
        return Math.min(discount, 0.2);
    }
}

// 테스트
@Test
void vipCustomerGets10PercentDiscount() {
    PricingService service = new PricingService();
    Customer vipCustomer = new Customer(true);  // VIP
    Order normalOrder = new Order(50000);      // 5만원
    
    double discount = service.calculateDiscount(normalOrder, vipCustomer);
    
    assertEquals(0.1, discount);
}
```

## 7. 예외 처리 테스트

```java
public class AccountService {
    private final AccountRepository repository;
    
    public AccountService(AccountRepository repository) {
        this.repository = repository;
    }
    
    public void withdraw(String accountId, double amount) {
        Account account = repository.findById(accountId)
            .orElseThrow(() -> new AccountNotFoundException(accountId));
            
        if (amount <= 0) {
            throw new InvalidAmountException("Amount must be positive");
        }
        
        if (account.getBalance() < amount) {
            throw new InsufficientFundsException("Not enough funds");
        }
        
        account.withdraw(amount);
        repository.save(account);
    }
}

// 테스트
@Test
void throwsExceptionWhenAccountNotFound() {
    AccountRepository mockRepo = mock(AccountRepository.class);
    when(mockRepo.findById("non-existent")).thenReturn(Optional.empty());
    
    AccountService service = new AccountService(mockRepo);
    
    assertThrows(AccountNotFoundException.class, () -> {
        service.withdraw("non-existent", 100);
    });
}
```

이러한 원칙과 패턴을 적용하면 코드는 더 모듈화되고, 테스트하기 쉬워지며, 장기적으로 유지보수가 용이해집니다.
