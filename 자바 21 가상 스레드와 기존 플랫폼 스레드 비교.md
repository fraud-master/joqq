# 자바 21 가상 스레드와 기존 플랫폼 스레드 비교

## 리소스 사용

**플랫폼 스레드**:
- OS 수준 스레드와 1:1 매핑
- 각 스레드당 약 1MB의 스택 메모리 필요
- 생성 비용이 높고 시스템 리소스를 많이 소모
- 일반적으로 수백 개 이상 생성 시 성능 문제 발생

**가상 스레드**:
- 경량 JVM 관리 스레드 (약 200~400바이트 메모리)
- 수백만 개 생성 가능
- 생성 및 폐기 비용이 매우 낮음

## 스케줄링 방식

**플랫폼 스레드**:
- OS 스케줄러에 의해 관리
- 컨텍스트 스위칭 비용이 높음
- 선점형 스케줄링 사용

**가상 스레드**:
- JVM에 의해 관리됨
- 적은 수의 캐리어 스레드(OS 스레드) 위에서 실행
- 협력적 스케줄링 활용 (블로킹 연산 시 자동 양보)

## I/O 및 블로킹 처리

**플랫폼 스레드**:
- 블로킹 I/O 시 스레드 전체가 차단됨
- 많은 동시 연결 처리를 위해 스레드 풀 필요
- 블로킹 작업이 많을수록 더 많은 스레드 필요

**가상 스레드**:
- 블로킹 작업에서 자동으로 언마운트(unmount)됨
- 블로킹 중에도 캐리어 스레드는 다른 가상 스레드 실행 가능
- "스레드당 하나의 태스크" 모델 실현 가능

## 사용 패턴

**플랫폼 스레드**:
- 일반적으로 스레드 풀을 통해 재사용
- 복잡한 풀 설정과 관리 필요 (크기, 큐 정책 등)
- 태스크를 스레드에 맞추는 방식

**가상 스레드**:
- 작업별로 새 스레드 생성 권장
- 스레드 풀링 필요 없음
- 스레드를 태스크에 맞추는 방식

## 성능 특성

**플랫폼 스레드**:
- CPU 바운드 작업에 효율적
- 적은 수의 장시간 실행 작업에 적합
- 컨텍스트 스위칭 비용 높음

**가상 스레드**:
- I/O 바운드 작업에 최적화
- 많은 수의 동시 작업에 효율적
- 짧은 대기 시간이 많은 작업에 이상적

## 동기화 및 주의사항

**플랫폼 스레드**:
- 모든 동기화 기법 사용 가능
- ThreadLocal 사용 일반적

**가상 스레드**:
- synchronized 블록에서 캐리어 스레드 고정 현상 주의
- ThreadLocal 사용 시 메모리 누수 가능성
- 스레드 기반 코드의 호환성은 유지됨

가상 스레드는 기존 스레드 모델의 확장이라기보다는 동시성 처리를 위한 새로운 패러다임이라고 볼 수 있습니다. 특히 많은 동시 연결이 필요한 서버 애플리케이션에서 큰 이점을 제공합니다.
