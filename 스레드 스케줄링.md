# 스레드 스케줄링 (Thread Scheduling)

스레드 스케줄링은 멀티스레딩 환경에서 여러 스레드가 CPU를 효율적으로 사용할 수 있도록 관리하는 프로세스입니다. 운영체제가 한정된 CPU 리소스를 여러 스레드에게 어떻게 할당할지 결정하는 메커니즘입니다.

## 1. 스케줄링이 필요한 이유

- **제한된 CPU 리소스**: 일반적으로 실행 가능한 스레드 수가 CPU 코어 수보다 많음
- **공정성 보장**: 모든 스레드가 적절한 실행 기회를 얻도록 함
- **시스템 성능 최적화**: 전체 시스템 처리량과 응답성 향상
- **우선순위 지원**: 중요한 작업을 먼저 처리할 수 있도록 함

## 2. 스케줄링 레벨

### 2.1. 사용자 수준 스케줄링
- 사용자 공간의 스레드 라이브러리가 관리
- 커널 개입 없이 스레드 간 전환
- 효율적이지만 멀티프로세서 활용 제한적

### 2.2. 커널 수준 스케줄링
- 운영체제 커널이 직접 스레드 스케줄링
- 진정한 병렬 실행 가능
- 컨텍스트 스위칭 비용이 더 높음

## 3. 주요 스케줄링 알고리즘

### 3.1. 선점형 스케줄링 (Preemptive Scheduling)
CPU를 사용 중인 스레드를 강제로 중지시키고 다른 스레드에게 CPU를 할당할 수 있는 방식

#### 3.1.1. 우선순위 기반 스케줄링
- 각 스레드에 우선순위 부여
- 높은 우선순위의 스레드가 낮은 우선순위 스레드보다 먼저 실행
- 우선순위 역전 문제 발생 가능

#### 3.1.2. 라운드 로빈 스케줄링
- 각 스레드에 동일한 시간 할당량(타임 퀀텀) 부여
- 시간 만료 시 다음 스레드로 전환
- 공정성 보장되나 컨텍스트 스위칭 오버헤드 증가

#### 3.1.3. 다단계 피드백 큐 (Multilevel Feedback Queue)
- 여러 개의 큐를 사용하며 각 큐마다 다른 우선순위와 타임 퀀텀 적용
- I/O 중심 작업에 높은 우선순위, CPU 중심 작업에 낮은 우선순위 할당
- 적응형 알고리즘으로 실행 특성에 따라 스레드 재배치

### 3.2. 비선점형 스케줄링 (Non-preemptive Scheduling)
CPU를 사용 중인 스레드가 자발적으로 양보하기 전까지 계속 실행되는 방식

#### 3.2.1. FCFS (First-Come, First-Served)
- 도착 순서대로 스레드 실행
- 구현 간단하나 짧은 작업이 긴 작업 뒤에서 대기하는 문제 발생(호위 효과)

#### 3.2.2. SJF (Shortest Job First)
- 실행 시간이 가장 짧은 스레드 먼저 실행
- 평균 대기 시간 최소화
- 실행 시간 예측 어려움

#### 3.2.3. 우선순위 스케줄링 (비선점형)
- 우선순위가 높은 스레드 먼저 실행
- 스레드가 자발적으로 CPU 양보 전까지 계속 실행
- 기아 현상 발생 가능

## 4. 실시간 스케줄링

### 4.1. 경성 실시간(Hard Real-time) 스케줄링
- 데드라인 내 반드시 실행 완료 보장
- 미션 크리티컬한 시스템에 사용(항공, 의료 장비 등)
- Rate Monotonic, Earliest Deadline First 등의 알고리즘 적용

### 4.2. 연성 실시간(Soft Real-time) 스케줄링
- 데드라인은 있으나 일부 위반 허용
- 멀티미디어 시스템, 게임 등에 사용
- 일반 스케줄링보다 엄격하지만 경성 실시간보다는 유연함

## 5. 자바에서의 스레드 스케줄링

### 5.1. 자바 스레드 우선순위
- `Thread.MIN_PRIORITY`(1)부터 `Thread.MAX_PRIORITY`(10)까지 설정 가능
- 기본값은 `Thread.NORM_PRIORITY`(5)
- `thread.setPriority(int priority)` 메소드로 설정

```java
Thread highPriorityThread = new Thread(() -> {
    // 작업 내용
});
highPriorityThread.setPriority(Thread.MAX_PRIORITY);
```

### 5.2. 양보(Yield)
- `Thread.yield()` 메소드로 동일 우선순위의 다른 스레드에게 실행 기회 제공
- 스케줄러에 대한 힌트일 뿐 보장은 없음

```java
public void run() {
    while (moreWorkToDo()) {
        // 일부 작업 수행
        Thread.yield(); // 다른 스레드에게 실행 기회 제공
    }
}
```

### 5.3. 스케줄링 제어의 한계
- 자바는 플랫폼에 독립적으로 설계되어 OS별 스케줄링 정책에 의존
- 우선순위는 상대적 힌트일 뿐 절대적 보장 없음
- Windows, Linux 등 플랫폼마다 우선순위 매핑 방식 다름

## 6. 스케줄링 관련 주요 개념

### 6.1. 컨텍스트 스위칭 (Context Switching)
- 한 스레드에서 다른 스레드로 CPU 제어권 이전
- 현재 스레드 상태 저장(레지스터, 스택 포인터 등)
- 다음 스레드 상태 복원
- 과도한 컨텍스트 스위칭은 성능 저하 유발

### 6.2. 스레드 상태 전이
- **생성(New)**: 스레드 생성 완료 상태
- **준비(Ready)**: 실행 대기 상태, 스케줄러에 의해 선택될 수 있음
- **실행(Running)**: CPU에서 실행 중인 상태
- **대기(Blocked/Waiting)**: I/O나 동기화 이벤트 대기 상태
- **종료(Terminated)**: 실행 완료 상태

### 6.3. 스케줄링 관련 문제

#### 6.3.1. 기아 현상 (Starvation)
- 낮은 우선순위 스레드가 실행 기회를 얻지 못하는 현상
- 해결책: 에이징(시간 경과에 따라 우선순위 점진적 증가)

#### 6.3.2. 우선순위 역전 (Priority Inversion)
- 낮은 우선순위 스레드가 높은 우선순위 스레드가 필요한 자원을 점유
- 해결책: 우선순위 상속(우선순위가 높은 스레드가 대기 중일 때 자원 보유 스레드의 우선순위 임시 상승)

#### 6.3.3. 경쟁 상태 (Race Condition)
- 여러 스레드가 동시에 공유 자원 접근 시 발생
- 해결책: 동기화 메커니즘(락, 세마포어 등) 사용

## 7. 스케줄링 성능 지표

- **처리량(Throughput)**: 단위 시간당 처리된 스레드 수
- **응답 시간(Response Time)**: 요청 후 첫 응답까지 걸리는 시간
- **대기 시간(Waiting Time)**: 스레드가 준비 큐에서 대기하는 시간
- **반환 시간(Turnaround Time)**: 스레드 제출부터 완료까지의 총 시간
- **CPU 활용률(CPU Utilization)**: CPU가 작업을 처리하는 시간 비율

## 8. 실제 운영체제별 스케줄링 정책

### 8.1. Linux (CFS: Completely Fair Scheduler)
- 프로세스/스레드에 가상 실행 시간(virtual runtime) 할당
- 실행 시간이 적은 프로세스에 우선권 부여
- 레드-블랙 트리로 실행 대상 관리

### 8.2. Windows
- 우선순위 기반 선점형 스케줄링
- 32단계 우선순위 레벨 (0-31)
- 동적 우선순위 부스팅으로 응답성 향상

### 8.3. macOS/iOS
- 우선순위 기반 선점형 스케줄링
- GCD(Grand Central Dispatch)로 작업 단위 관리
- QoS(Quality of Service) 레벨로 우선순위 구분

## 9. 효율적인 스레드 사용을 위한 고려사항

- **적절한 스레드 수**: CPU 코어 수와 작업 특성 고려
- **과도한 스레드 생성 회피**: 스레드 풀 사용
- **I/O와 CPU 작업 분리**: I/O 작업은 별도 스레드로 처리
- **불필요한 동기화 최소화**: 락 획득 시간 최소화
- **스레드 친화성(Affinity)**: 특정 코어에 스레드 바인딩 고려

이상의 스레드 스케줄링 개념은 현대 운영체제와 프로그래밍 언어의 멀티스레딩 환경에서 효율적인 애플리케이션 설계와 최적화에 중요한 기초가 됩니다.
