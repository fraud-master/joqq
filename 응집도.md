응집도는 모듈 내부 요소들이 얼마나 밀접하게 관련되어 있는지를 나타내는 지표입니다. 응집도가 높을수록 좋은 설계이며, 다양한 응집도 유형과 Spring에서의 실제 예제를 보여드리겠습니다.

## 1. 응집도의 7가지 유형 (낮은 순서부터)

### 1.1 우연적 응집도 (Coincidental Cohesion) - 최악

```java
// 나쁜 예: 관련 없는 기능들이 하나의 클래스에 모여있음
@Service
public class UtilityService {
    
    // 사용자 관련 기능
    public void saveUser(User user) {
        userRepository.save(user);
    }
    
    // 이메일 관련 기능
    public void sendEmail(String to, String subject, String body) {
        emailService.send(to, subject, body);
    }
    
    // 수학 계산 기능
    public double calculateTax(double amount) {
        return amount * 0.1;
    }
    
    // 로그 기능
    public void writeLog(String message) {
        logger.info(message);
    }
}
```

### 1.2 논리적 응집도 (Logical Cohesion) - 매우 나쁨

```java
// 나쁜 예: 비슷한 성격의 기능이지만 플래그로 구분
@Service
public class FileHandler {
    
    public void handleFile(String filename, String operation) {
        switch (operation) {
            case "READ":
                readFile(filename);
                break;
            case "WRITE":
                writeFile(filename);
                break;
            case "DELETE":
                deleteFile(filename);
                break;
            case "BACKUP":
                backupFile(filename);
                break;
        }
    }
    
    private void readFile(String filename) { /* ... */ }
    private void writeFile(String filename) { /* ... */ }
    private void deleteFile(String filename) { /* ... */ }
    private void backupFile(String filename) { /* ... */ }
}
```

### 1.3 시간적 응집도 (Temporal Cohesion) - 나쁨

```java
// 나쁜 예: 시간적으로 함께 실행되지만 관련성이 낮음
@Component
public class SystemInitializer {
    
    @PostConstruct
    public void initialize() {
        // 데이터베이스 연결 초기화
        initializeDatabase();
        
        // 캐시 서버 연결
        initializeCache();
        
        // 메시지 큐 연결
        initializeMessageQueue();
        
        // 로깅 시스템 초기화
        initializeLogging();
        
        // 보안 모듈 초기화
        initializeSecurity();
    }
    
    // 각 초기화 메서드들...
}
```

### 1.4 절차적 응집도 (Procedural Cohesion) - 보통

```java
// 보통 예: 특정 절차를 따라 순서대로 실행
@Service
public class OrderProcessingService {
    
    public void processOrder(Order order) {
        // 1. 주문 검증
        validateOrder(order);
        
        // 2. 재고 확인
        checkInventory(order);
        
        // 3. 결제 처리
        processPayment(order);
        
        // 4. 배송 준비
        prepareShipment(order);
        
        // 5. 주문 완료 처리
        completeOrder(order);
    }
    
    private void validateOrder(Order order) { /* ... */ }
    private void checkInventory(Order order) { /* ... */ }
    private void processPayment(Order order) { /* ... */ }
    private void prepareShipment(Order order) { /* ... */ }
    private void completeOrder(Order order) { /* ... */ }
}
```

### 1.5 통신적 응집도 (Communicational Cohesion) - 좋음

```java
// 좋은 예: 같은 데이터를 다루는 기능들이 모여있음
@Service
public class UserProfileService {
    
    public UserProfile updateUserProfile(Long userId, UpdateProfileRequest request) {
        // 사용자 데이터 조회
        User user = findUserById(userId);
        
        // 프로필 업데이트
        updateUserBasicInfo(user, request);
        
        // 프로필 이미지 처리
        updateProfileImage(user, request.getImageFile());
        
        // 변경사항 저장
        saveUser(user);
        
        // 프로필 캐시 업데이트
        updateProfileCache(user);
        
        return createUserProfile(user);
    }
    
    private User findUserById(Long userId) { /* ... */ }
    private void updateUserBasicInfo(User user, UpdateProfileRequest request) { /* ... */ }
    private void updateProfileImage(User user, MultipartFile image) { /* ... */ }
    private void saveUser(User user) { /* ... */ }
    private void updateProfileCache(User user) { /* ... */ }
    private UserProfile createUserProfile(User user) { /* ... */ }
}
```

### 1.6 순차적 응집도 (Sequential Cohesion) - 매우 좋음

```java
// 매우 좋은 예: 한 기능의 출력이 다음 기능의 입력이 되는 경우
@Service
public class ReportGenerationService {
    
    public Report generateSalesReport(ReportRequest request) {
        // 1. 원본 데이터 수집
        List<SalesData> rawData = collectSalesData(request);
        
        // 2. 데이터 정제 및 변환
        List<ProcessedSalesData> processedData = processRawData(rawData);
        
        // 3. 통계 계산
        SalesStatistics statistics = calculateStatistics(processedData);
        
        // 4. 차트 데이터 생성
        List<ChartData> chartData = generateChartData(processedData, statistics);
        
        // 5. 최종 보고서 생성
        Report report = generateReport(statistics, chartData);
        
        return report;
    }
    
    private List<SalesData> collectSalesData(ReportRequest request) { /* ... */ }
    private List<ProcessedSalesData> processRawData(List<SalesData> raw) { /* ... */ }
    private SalesStatistics calculateStatistics(List<ProcessedSalesData> data) { /* ... */ }
    private List<ChartData> generateChartData(List<ProcessedSalesData> data, SalesStatistics stats) { /* ... */ }
    private Report generateReport(SalesStatistics stats, List<ChartData> charts) { /* ... */ }
}
```

### 1.7 기능적 응집도 (Functional Cohesion) - 최고

```java
// 최고의 예: 하나의 명확한 기능만 수행
@Service
public class EmailValidationService {
    
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");
    
    /**
     * 이메일 주소 형식이 유효한지 검증
     */
    public boolean validateEmail(String email) {
        if (email == null || email.trim().isEmpty()) {
            return false;
        }
        
        // 기본 패턴 검증
        if (!EMAIL_PATTERN.matcher(email).matches()) {
            return false;
        }
        
        // 추가 검증 로직
        return validateEmailLength(email) && 
               validateEmailSpecialCases(email);
    }
    
    private boolean validateEmailLength(String email) {
        return email.length() <= 254; // RFC 5321 표준
    }
    
    private boolean validateEmailSpecialCases(String email) {
        // 연속된 점 확인
        if (email.contains("..")) {
            return false;
        }
        
        // 처음이나 끝에 점 확인
        return !email.startsWith(".") && !email.endsWith(".");
    }
}
```

## 2. Spring에서의 응집도 개선 예제

### 2.1 Repository 계층의 기능적 응집도

```java
// 좋은 예: 특정 엔티티의 데이터 접근만 담당
@Repository
public class UserRepository {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    public User findById(Long id) {
        return entityManager.find(User.class, id);
    }
    
    public User findByEmail(String email) {
        TypedQuery<User> query = entityManager.createQuery(
            "SELECT u FROM User u WHERE u.email = :email", User.class);
        query.setParameter("email", email);
        return query.getSingleResult();
    }
    
    public void save(User user) {
        if (user.getId() == null) {
            entityManager.persist(user);
        } else {
            entityManager.merge(user);
        }
    }
    
    public void delete(User user) {
        if (entityManager.contains(user)) {
            entityManager.remove(user);
        } else {
            entityManager.remove(entityManager.merge(user));
        }
    }
    
    public List<User> findActiveUsers() {
        return entityManager.createQuery(
            "SELECT u FROM User u WHERE u.active = true", User.class)
            .getResultList();
    }
}
```

### 2.2 Service 계층의 순차적 응집도

```java
// 좋은 예: 주문 생성 과정이 순차적으로 진행됨
@Service
@Transactional
public class OrderCreationService {
    
    public Order createOrder(CreateOrderRequest request) {
        // 1. 요청 검증 (이전 단계의 결과를 다음 단계에서 사용)
        ValidatedOrderData validatedData = validateOrderRequest(request);
        
        // 2. 재고 확인 및 예약
        ReservationResult reservation = reserveInventory(validatedData);
        
        // 3. 할인 적용
        PricingInfo pricing = calculatePricing(validatedData, reservation);
        
        // 4. 주문 엔티티 생성
        Order order = createOrderEntity(validatedData, reservation, pricing);
        
        // 5. 주문 저장 및 이벤트 발행
        Order savedOrder = saveOrderAndPublishEvents(order);
        
        return savedOrder;
    }
    
    private ValidatedOrderData validateOrderRequest(CreateOrderRequest request) {
        // 사용자 존재 여부 확인
        User user = userService.findById(request.getUserId());
        
        // 상품 존재 여부 및 활성화 상태 확인
        List<Product> products = validateProductsExist(request.getOrderItems());
        
        // 주문 수량 검증
        validateOrderQuantities(request.getOrderItems());
        
        return ValidatedOrderData.builder()
                .user(user)
                .products(products)
                .orderItems(request.getOrderItems())
                .build();
    }
    
    private ReservationResult reserveInventory(ValidatedOrderData data) {
        List<InventoryReservation> reservations = new ArrayList<>();
        
        for (OrderItemRequest item : data.getOrderItems()) {
            InventoryReservation reservation = inventoryService.reserve(
                item.getProductId(), 
                item.getQuantity()
            );
            reservations.add(reservation);
        }
        
        return ReservationResult.builder()
                .reservations(reservations)
                .build();
    }
    
    private PricingInfo calculatePricing(ValidatedOrderData data, ReservationResult reservation) {
        BigDecimal subtotal = calculateSubtotal(data.getOrderItems(), data.getProducts());
        BigDecimal discount = discountService.calculateDiscount(data.getUser(), subtotal);
        BigDecimal tax = taxService.calculateTax(subtotal.subtract(discount));
        BigDecimal total = subtotal.subtract(discount).add(tax);
        
        return PricingInfo.builder()
                .subtotal(subtotal)
                .discount(discount)
                .tax(tax)
                .total(total)
                .build();
    }
    
    // 나머지 메서드들...
}
```

### 2.3 Controller 계층의 기능적 응집도

```java
// 좋은 예: 특정 리소스(User)에 대한 HTTP 요청 처리만 담당
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<UserResponse> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(UserResponse.from(user));
    }
    
    @PostMapping
    public ResponseEntity<UserResponse> createUser(@Valid @RequestBody CreateUserRequest request) {
        User user = userService.createUser(request);
        return ResponseEntity.status(HttpStatus.CREATED)
                           .body(UserResponse.from(user));
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<UserResponse> updateUser(@PathVariable Long id,
                                                   @Valid @RequestBody UpdateUserRequest request) {
        User user = userService.updateUser(id, request);
        return ResponseEntity.ok(UserResponse.from(user));
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
    
    @GetMapping("/{id}/profile")
    public ResponseEntity<UserProfileResponse> getUserProfile(@PathVariable Long id) {
        UserProfile profile = userService.getUserProfile(id);
        return ResponseEntity.ok(UserProfileResponse.from(profile));
    }
}
```

## 3. 응집도 개선 예제

### 3.1 나쁜 응집도를 좋은 응집도로 개선

```java
// Before: 낮은 응집도 (여러 책임이 섞여있음)
@Service
public class BadOrderService {
    
    public Order processOrder(OrderRequest request) {
        // 사용자 검증
        User user = userRepository.findById(request.getUserId());
        if (user == null) {
            throw new UserNotFoundException(request.getUserId());
        }
        
        // 이메일 발송 로직
        String emailContent = buildEmailContent(request);
        emailService.sendEmail(user.getEmail(), "Order Confirmation", emailContent);
        
        // 재고 관리
        for (OrderItem item : request.getItems()) {
            Product product = productRepository.findById(item.getProductId());
            if (product.getStock() < item.getQuantity()) {
                throw new InsufficientStockException(item.getProductId());
            }
            product.decreaseStock(item.getQuantity());
            productRepository.save(product);
        }
        
        // 가격 계산
        BigDecimal total = BigDecimal.ZERO;
        for (OrderItem item : request.getItems()) {
            Product product = productRepository.findById(item.getProductId());
            BigDecimal itemTotal = product.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()));
            total = total.add(itemTotal);
        }
        
        // 주문 생성
        Order order = new Order();
        order.setUser(user);
        order.setItems(request.getItems());
        order.setTotal(total);
        order.setStatus(OrderStatus.CONFIRMED);
        
        return orderRepository.save(order);
    }
}

// After: 높은 응집도 (각각의 서비스가 하나의 책임만 가짐)
@Service
public class OrderService {
    
    private final UserValidationService userValidationService;
    private final InventoryService inventoryService;
    private final PricingService pricingService;
    private final OrderRepository orderRepository;
    private final OrderNotificationService orderNotificationService;
    
    public Order processOrder(OrderRequest request) {
        // 1. 사용자 검증
        User user = userValidationService.validateAndGetUser(request.getUserId());
        
        // 2. 재고 확인 및 예약
        InventoryReservation reservation = inventoryService.reserveItems(request.getItems());
        
        // 3. 가격 계산
        OrderPricing pricing = pricingService.calculateOrderPricing(request.getItems());
        
        // 4. 주문 생성
        Order order = createOrder(user, request.getItems(), pricing);
        Order savedOrder = orderRepository.save(order);
        
        // 5. 알림 처리
        orderNotificationService.sendOrderConfirmation(savedOrder);
        
        return savedOrder;
    }
    
    private Order createOrder(User user, List<OrderItem> items, OrderPricing pricing) {
        return Order.builder()
                .user(user)
                .items(items)
                .subtotal(pricing.getSubtotal())
                .tax(pricing.getTax())
                .total(pricing.getTotal())
                .status(OrderStatus.CONFIRMED)
                .build();
    }
}

// 각각의 서비스는 단일 책임만 가짐
@Service
public class UserValidationService {
    
    public User validateAndGetUser(Long userId) {
        return userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
    }
}

@Service
public class InventoryService {
    
    @Transactional
    public InventoryReservation reserveItems(List<OrderItem> items) {
        List<ReservationItem> reservations = new ArrayList<>();
        
        for (OrderItem item : items) {
            Product product = findProductById(item.getProductId());
            validateStock(product, item.getQuantity());
            decreaseStock(product, item.getQuantity());
            
            reservations.add(ReservationItem.builder()
                    .productId(product.getId())
                    .quantity(item.getQuantity())
                    .build());
        }
        
        return InventoryReservation.builder()
                .reservations(reservations)
                .reservedAt(LocalDateTime.now())
                .build();
    }
    
    private Product findProductById(Long productId) {
        return productRepository.findById(productId)
                .orElseThrow(() -> new ProductNotFoundException(productId));
    }
    
    private void validateStock(Product product, int requestedQuantity) {
        if (product.getStock() < requestedQuantity) {
            throw new InsufficientStockException(product.getId(), requestedQuantity, product.getStock());
        }
    }
    
    private void decreaseStock(Product product, int quantity) {
        product.decreaseStock(quantity);
        productRepository.save(product);
    }
}

@Service
public class PricingService {
    
    public OrderPricing calculateOrderPricing(List<OrderItem> items) {
        BigDecimal subtotal = calculateSubtotal(items);
        BigDecimal tax = calculateTax(subtotal);
        BigDecimal total = subtotal.add(tax);
        
        return OrderPricing.builder()
                .subtotal(subtotal)
                .tax(tax)
                .total(total)
                .build();
    }
    
    private BigDecimal calculateSubtotal(List<OrderItem> items) {
        return items.stream()
                .map(this::calculateItemTotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    private BigDecimal calculateItemTotal(OrderItem item) {
        Product product = productRepository.findById(item.getProductId())
                .orElseThrow(() -> new ProductNotFoundException(item.getProductId()));
        
        return product.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()));
    }
    
    private BigDecimal calculateTax(BigDecimal subtotal) {
        return subtotal.multiply(BigDecimal.valueOf(0.1)); // 10% 세율
    }
}

@Service
public class OrderNotificationService {
    
    private final EmailService emailService;
    private final SmsService smsService;
    
    public void sendOrderConfirmation(Order order) {
        sendOrderConfirmationEmail(order);
        sendOrderConfirmationSms(order);
    }
    
    private void sendOrderConfirmationEmail(Order order) {
        String emailContent = buildEmailContent(order);
        emailService.sendEmail(
            order.getUser().getEmail(),
            "주문 확인",
            emailContent
        );
    }
    
    private void sendOrderConfirmationSms(Order order) {
        if (order.getUser().getPhoneNumber() != null) {
            String smsContent = buildSmsContent(order);
            smsService.sendSms(
                order.getUser().getPhoneNumber(),
                smsContent
            );
        }
    }
    
    private String buildEmailContent(Order order) {
        return EmailTemplate.builder()
                .orderNumber(order.getOrderNumber())
                .customerName(order.getUser().getName())
                .orderItems(order.getItems())
                .totalAmount(order.getTotal())
                .build()
                .render();
    }
    
    private String buildSmsContent(Order order) {
        return String.format("주문이 확정되었습니다. 주문번호: %s, 총액: %s원", 
                           order.getOrderNumber(), 
                           order.getTotal());
    }
}
```

## 4. 응집도 측정 및 개선 팁

### 4.1 응집도 측정 방법

```java
// 체크리스트:
// 1. 메서드가 하나의 명확한 업무를 수행하는가?
// 2. 클래스 내 메서드들이 동일한 데이터를 조작하는가?
// 3. 클래스명과 메서드명이 명확하고 일관성이 있는가?
// 4. 클래스의 책임이 단일한가?

// 좋은 응집도의 예
@Service
public class PasswordService {
    
    private final PasswordEncoder passwordEncoder;
    private final PasswordValidator passwordValidator;
    private final PasswordHistoryRepository passwordHistoryRepository;
    
    // 모든 메서드가 비밀번호와 관련됨
    public String hashPassword(String plainPassword) {
        passwordValidator.validate(plainPassword);
        return passwordEncoder.encode(plainPassword);
    }
    
    public boolean verifyPassword(String plainPassword, String hashedPassword) {
        return passwordEncoder.matches(plainPassword, hashedPassword);
    }
    
    public void changePassword(Long userId, String oldPassword, String newPassword) {
        validateOldPassword(userId, oldPassword);
        validateNewPassword(userId, newPassword);
        String hashedNewPassword = hashPassword(newPassword);
        updateUserPassword(userId, hashedNewPassword);
        savePasswordHistory(userId, hashedNewPassword);
    }
    
    public boolean isPasswordInHistory(Long userId, String newPassword) {
        List<String> recentPasswords = passwordHistoryRepository.findRecentPasswords(userId, 5);
        return recentPasswords.stream()
                .anyMatch(historical -> passwordEncoder.matches(newPassword, historical));
    }
    
    // 모든 private 메서드도 비밀번호 관련 작업
    private void validateOldPassword(Long userId, String oldPassword) { /* ... */ }
    private void validateNewPassword(Long userId, String newPassword) { /* ... */ }
    private void updateUserPassword(Long userId, String hashedPassword) { /* ... */ }
    private void savePasswordHistory(Long userId, String hashedPassword) { /* ... */ }
}
```

### 4.2 응집도 개선 가이드라인

```java
// 1. 단일 책임 원칙 적용
// Before
@Service
public class UserManagementService {
    public void createUser(User user) { /* ... */ }
    public void updateUser(User user) { /* ... */ }
    public void deleteUser(Long id) { /* ... */ }
    public void sendWelcomeEmail(User user) { /* ... */ }  // 이메일 관련 책임
    public void generateReport() { /* ... */ }             // 보고서 관련 책임
}

// After - 책임을 분리
@Service
public class UserService {
    public void createUser(User user) { /* ... */ }
    public void updateUser(User user) { /* ... */ }
    public void deleteUser(Long id) { /* ... */ }
}

@Service
public class UserEmailService {
    public void sendWelcomeEmail(User user) { /* ... */ }
    public void sendPasswordResetEmail(User user) { /* ... */ }
}

@Service
public class UserReportService {
    public void generateUserReport() { /* ... */ }
    public void generateActivityReport() { /* ... */ }
}
```

### 4.3 도메인별 응집도 향상

```java
// 도메인 객체에 행동을 포함시켜 응집도 향상
@Entity
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Enumerated(EnumType.STRING)
    private OrderStatus status;
    
    private BigDecimal total;
    
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
    private List<OrderItem> items;
    
    // 도메인 로직을 도메인 객체 내부에 포함
    public boolean canBeCancelled() {
        return status == OrderStatus.PENDING || status == OrderStatus.CONFIRMED;
    }
    
    public void cancel() {
        if (!canBeCancelled()) {
            throw new InvalidOrderStatusException("Cannot cancel order in status: " + status);
        }
        this.status = OrderStatus.CANCELLED;
    }
    
    public BigDecimal calculateTotal() {
        return items.stream()
                .map(OrderItem::getSubtotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    public boolean isComplete() {
        return status == OrderStatus.DELIVERED || status == OrderStatus.COMPLETED;
    }
    
    public void ship() {
        if (status != OrderStatus.CONFIRMED) {
            throw new InvalidOrderStatusException("Cannot ship order in status: " + status);
        }
        this.status = OrderStatus.SHIPPED;
    }
}

// 서비스는 도메인 객체의 행동을 조합
@Service
@Transactional
public class OrderService {
    
    public void cancelOrder(Long orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException(orderId));
        
        // 도메인 객체의 비즈니스 로직 사용
        order.cancel();
        
        // 부수 효과 처리
        restoreInventory(order);
        refundPayment(order);
        notifyCustomer(order);
        
        orderRepository.save(order);
    }
    
    private void restoreInventory(Order order) { /* ... */ }
    private void refundPayment(Order order) { /* ... */ }
    private void notifyCustomer(Order order) { /* ... */ }
}
```

## 5. 실제 프로젝트 응집도 개선 사례

### 5.1 Configuration 클래스의 응집도

```java
// Before: 여러 설정이 하나의 클래스에 모여있음 (낮은 응집도)
@Configuration
public class ApplicationConfig {
    
    @Bean
    public DataSource dataSource() { /* ... */ }
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate() { /* ... */ }
    
    @Bean
    public RestTemplate restTemplate() { /* ... */ }
    
    @Bean
    public PasswordEncoder passwordEncoder() { /* ... */ }
    
    @Bean
    public JwtTokenProvider jwtTokenProvider() { /* ... */ }
}

// After: 목적별로 설정 클래스 분리 (높은 응집도)
@Configuration
public class DatabaseConfig {
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public JpaTransactionManager transactionManager(DataSource dataSource) {
        return new JpaTransactionManager();
    }
}

@Configuration
public class RedisConfig {
    
    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        LettuceConnectionFactory factory = new LettuceConnectionFactory();
        factory.setValidateConnection(true);
        return factory;
    }
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}

@Configuration
public class SecurityConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public JwtTokenProvider jwtTokenProvider() {
        return new JwtTokenProvider();
    }
    
    @Bean
    public AuthenticationManager authenticationManager() {
        return new ProviderManager(Arrays.asList(authenticationProvider()));
    }
}

@Configuration
public class WebConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory());
        return restTemplate;
    }
    
    @Bean
    public WebMvcConfigurer webMvcConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**")
                       .allowedOrigins("*")
                       .allowedMethods("GET", "POST", "PUT", "DELETE")
                       .allowedHeaders("*");
           }
       };
   }
}
```

### 5.2 Validator 클래스의 기능적 응집도

```java
// Before: 여러 검증 로직이 섞여있음 (낮은 응집도)
@Component
public class RequestValidator {
    
    public void validate(Object request) {
        if (request instanceof CreateUserRequest) {
            validateUserRequest((CreateUserRequest) request);
        } else if (request instanceof CreateOrderRequest) {
            validateOrderRequest((CreateOrderRequest) request);
        } else if (request instanceof CreateProductRequest) {
            validateProductRequest((CreateProductRequest) request);
        }
    }
    
    private void validateUserRequest(CreateUserRequest request) { /* ... */ }
    private void validateOrderRequest(CreateOrderRequest request) { /* ... */ }
    private void validateProductRequest(CreateProductRequest request) { /* ... */ }
}

// After: 각 도메인별로 분리 (높은 응집도)
@Component
public class UserRequestValidator {
    
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");
    
    public void validate(CreateUserRequest request) {
        validateEmail(request.getEmail());
        validatePassword(request.getPassword());
        validateName(request.getName());
        validatePhoneNumber(request.getPhoneNumber());
    }
    
    private void validateEmail(String email) {
        if (email == null || email.trim().isEmpty()) {
            throw new ValidationException("Email is required");
        }
        
        if (!EMAIL_PATTERN.matcher(email).matches()) {
            throw new ValidationException("Invalid email format");
        }
    }
    
    private void validatePassword(String password) {
        if (password == null || password.length() < 8) {
            throw new ValidationException("Password must be at least 8 characters");
        }
        
        if (!password.matches(".*[A-Z].*") || 
            !password.matches(".*[a-z].*") || 
            !password.matches(".*\\d.*")) {
            throw new ValidationException("Password must contain uppercase, lowercase, and numbers");
        }
    }
    
    private void validateName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new ValidationException("Name is required");
        }
        
        if (name.length() > 100) {
            throw new ValidationException("Name cannot exceed 100 characters");
        }
    }
    
    private void validatePhoneNumber(String phoneNumber) {
        if (phoneNumber != null && !phoneNumber.matches("\\d{10,11}")) {
            throw new ValidationException("Invalid phone number format");
        }
    }
}

@Component
public class OrderRequestValidator {
    
    public void validate(CreateOrderRequest request) {
        validateUserId(request.getUserId());
        validateOrderItems(request.getOrderItems());
        validateShippingAddress(request.getShippingAddress());
    }
    
    private void validateUserId(Long userId) {
        if (userId == null || userId <= 0) {
            throw new ValidationException("Valid user ID is required");
        }
    }
    
    private void validateOrderItems(List<OrderItemRequest> items) {
        if (items == null || items.isEmpty()) {
            throw new ValidationException("Order must contain at least one item");
        }
        
        for (OrderItemRequest item : items) {
            validateOrderItem(item);
        }
    }
    
    private void validateOrderItem(OrderItemRequest item) {
        if (item.getProductId() == null || item.getProductId() <= 0) {
            throw new ValidationException("Valid product ID is required");
        }
        
        if (item.getQuantity() == null || item.getQuantity() <= 0) {
            throw new ValidationException("Quantity must be greater than 0");
        }
        
        if (item.getQuantity() > 100) {
            throw new ValidationException("Quantity cannot exceed 100");
        }
    }
    
    private void validateShippingAddress(ShippingAddress address) {
        if (address == null) {
            throw new ValidationException("Shipping address is required");
        }
        
        if (address.getStreet() == null || address.getStreet().trim().isEmpty()) {
            throw new ValidationException("Street address is required");
        }
        
        if (address.getCity() == null || address.getCity().trim().isEmpty()) {
            throw new ValidationException("City is required");
        }
        
        if (address.getZipCode() == null || !address.getZipCode().matches("\\d{5}")) {
            throw new ValidationException("Valid zip code is required");
        }
    }
}
```

### 5.3 Event Handler의 응집도

```java
// Before: 여러 이벤트를 하나의 핸들러에서 처리 (낮은 응집도)
@Component
public class EventHandler {
    
    @EventListener
    public void handle(UserRegisteredEvent event) {
        sendWelcomeEmail(event.getUser());
    }
    
    @EventListener
    public void handle(OrderCreatedEvent event) {
        updateInventory(event.getOrder());
    }
    
    @EventListener
    public void handle(PaymentCompletedEvent event) {
        updateOrderStatus(event.getOrderId());
    }
    
    @EventListener
    public void handle(UserDeactivatedEvent event) {
        anonymizeUserData(event.getUserId());
    }
}

// After: 도메인별로 이벤트 핸들러 분리 (높은 응집도)
@Component
public class UserEventHandler {
    
    private final EmailService emailService;
    private final UserService userService;
    private final AuditService auditService;
    
    @EventListener
    @Async
    public void handleUserRegistered(UserRegisteredEvent event) {
        log.info("처리 중: 사용자 등록 이벤트 - User ID: {}", event.getUser().getId());
        
        // 환영 이메일 발송
        sendWelcomeEmail(event.getUser());
        
        // 환영 포인트 지급
        awardWelcomePoints(event.getUser());
        
        // 가입 통계 업데이트
        updateRegistrationStatistics(event.getUser());
        
        log.info("완료: 사용자 등록 이벤트 처리 - User ID: {}", event.getUser().getId());
    }
    
    @EventListener
    @Async
    public void handleUserDeactivated(UserDeactivatedEvent event) {
        log.info("처리 중: 사용자 비활성화 이벤트 - User ID: {}", event.getUserId());
        
        // 사용자 데이터 익명화
        anonymizeUserData(event.getUserId());
        
        // 활성 세션 무효화
        invalidateUserSessions(event.getUserId());
        
        // 구독 취소
        cancelUserSubscriptions(event.getUserId());
        
        log.info("완료: 사용자 비활성화 이벤트 처리 - User ID: {}", event.getUserId());
    }
    
    @EventListener
    @Async
    public void handlePasswordChanged(PasswordChangedEvent event) {
        log.info("처리 중: 비밀번호 변경 이벤트 - User ID: {}", event.getUserId());
        
        // 보안 알림 이메일 발송
        sendPasswordChangeNotification(event.getUserId());
        
        // 다른 세션 로그아웃
        logoutOtherSessions(event.getUserId(), event.getSessionId());
        
        // 감사 로그 기록
        auditService.recordPasswordChange(event.getUserId());
        
        log.info("완료: 비밀번호 변경 이벤트 처리 - User ID: {}", event.getUserId());
    }
    
    private void sendWelcomeEmail(User user) {
        try {
            String content = generateWelcomeEmailContent(user);
            emailService.sendEmail(user.getEmail(), "환영합니다!", content);
        } catch (Exception e) {
            log.error("환영 이메일 발송 실패 - User ID: {}", user.getId(), e);
        }
    }
    
    private void awardWelcomePoints(User user) {
        try {
            pointService.awardPoints(user.getId(), 1000, "가입 축하 포인트");
        } catch (Exception e) {
            log.error("환영 포인트 지급 실패 - User ID: {}", user.getId(), e);
        }
    }
    
    // 나머지 메서드들...
}

@Component
public class OrderEventHandler {
    
    private final InventoryService inventoryService;
    private final NotificationService notificationService;
    private final OrderService orderService;
    
    @EventListener
    @Transactional
    public void handleOrderCreated(OrderCreatedEvent event) {
        log.info("처리 중: 주문 생성 이벤트 - Order ID: {}", event.getOrder().getId());
        
        Order order = event.getOrder();
        
        // 재고 업데이트
        updateInventory(order);
        
        // 주문 확인 알림 발송
        sendOrderConfirmation(order);
        
        // 배송 준비 작업 시작
        initiateShippingPreparation(order);
        
        log.info("완료: 주문 생성 이벤트 처리 - Order ID: {}", order.getId());
    }
    
    @EventListener
    @Async
    public void handleOrderCancelled(OrderCancelledEvent event) {
        log.info("처리 중: 주문 취소 이벤트 - Order ID: {}", event.getOrderId());
        
        Order order = orderService.findById(event.getOrderId());
        
        // 재고 복원
        restoreInventory(order);
        
        // 결제 환불 처리
        processRefund(order);
        
        // 취소 알림 발송
        sendCancellationNotification(order);
        
        log.info("완료: 주문 취소 이벤트 처리 - Order ID: {}", event.getOrderId());
    }
    
    @EventListener
    @Transactional
    public void handleOrderShipped(OrderShippedEvent event) {
        log.info("처리 중: 주문 배송 이벤트 - Order ID: {}", event.getOrderId());
        
        Order order = orderService.findById(event.getOrderId());
        
        // 배송 추적 번호 생성
        generateTrackingNumber(order);
        
        // 배송 시작 알림
        sendShippingNotification(order);
        
        // 배송 상태 업데이트
        updateShippingStatus(order);
        
        log.info("완료: 주문 배송 이벤트 처리 - Order ID: {}", event.getOrderId());
    }
    
    private void updateInventory(Order order) {
        for (OrderItem item : order.getItems()) {
            inventoryService.decreaseStock(item.getProduct().getId(), item.getQuantity());
        }
    }
    
    private void restoreInventory(Order order) {
        for (OrderItem item : order.getItems()) {
            inventoryService.increaseStock(item.getProduct().getId(), item.getQuantity());
        }
    }
    
    // 나머지 메서드들...
}

@Component
public class PaymentEventHandler {
    
    private final OrderService orderService;
    private final PaymentService paymentService;
    private final NotificationService notificationService;
    
    @EventListener
    @Transactional
    public void handlePaymentCompleted(PaymentCompletedEvent event) {
        log.info("처리 중: 결제 완료 이벤트 - Payment ID: {}", event.getPaymentId());
        
        // 주문 상태 업데이트
        updateOrderStatus(event.getOrderId(), OrderStatus.PAID);
        
        // 결제 영수증 발송
        sendPaymentReceipt(event.getPaymentId());
        
        // 포인트 적립
        awardPurchasePoints(event.getOrderId());
        
        log.info("완료: 결제 완료 이벤트 처리 - Payment ID: {}", event.getPaymentId());
    }
    
    @EventListener
    @Async
    public void handlePaymentFailed(PaymentFailedEvent event) {
        log.info("처리 중: 결제 실패 이벤트 - Payment ID: {}", event.getPaymentId());
        
        // 주문 상태 업데이트
        updateOrderStatus(event.getOrderId(), OrderStatus.PAYMENT_FAILED);
        
        // 실패 알림 발송
        sendPaymentFailureNotification(event.getOrderId());
        
        // 재고 복원 (필요시)
        restoreInventoryIfNeeded(event.getOrderId());
        
        log.info("완료: 결제 실패 이벤트 처리 - Payment ID: {}", event.getPaymentId());
    }
    
    private void updateOrderStatus(Long orderId, OrderStatus status) {
        Order order = orderService.findById(orderId);
        order.updateStatus(status);
        orderService.save(order);
    }
    
    private void sendPaymentReceipt(Long paymentId) {
        Payment payment = paymentService.findById(paymentId);
        Order order = orderService.findById(payment.getOrderId());
        
        String receiptContent = generateReceiptContent(payment, order);
        notificationService.sendEmail(
            order.getUser().getEmail(),
            "결제 영수증",
            receiptContent
        );
    }
    
    // 나머지 메서드들...
}
```

### 5.4 Cache 관련 서비스의 응집도

```java
// Before: 여러 종류의 캐시 처리가 섞여있음 (낮은 응집도)
@Service
public class CacheService {
    
    @Cacheable("users")
    public User getUserById(Long id) { /* ... */ }
    
    @Cacheable("products")
    public Product getProductById(Long id) { /* ... */ }
    
    @Cacheable("orders")
    public Order getOrderById(Long id) { /* ... */ }
    
    @CacheEvict(value = "users", key = "#user.id")
    public void updateUser(User user) { /* ... */ }
    
    @CacheEvict(value = "products", key = "#product.id")
    public void updateProduct(Product product) { /* ... */ }
}

// After: 도메인별로 캐시 서비스 분리 (높은 응집도)
@Service
public class UserCacheService {
    
    @Cacheable(value = "users", key = "#id")
    public User findById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
    
    @Cacheable(value = "users", key = "#email")
    public User findByEmail(String email) {
        return userRepository.findByEmail(email).orElse(null);
    }
    
    @CacheEvict(value = "users", key = "#user.id")
    public void evictUserCache(User user) {
        log.debug("사용자 캐시 무효화 - ID: {}", user.getId());
    }
    
    @CacheEvict(value = "users", key = "#id")
    public void evictUserCacheById(Long id) {
        log.debug("사용자 캐시 무효화 - ID: {}", id);
    }
    
    @CacheEvict(value = "users", allEntries = true)
    public void evictAllUsersCache() {
        log.debug("모든 사용자 캐시 무효화");
    }
    
    @CachePut(value = "users", key = "#user.id")
    public User updateUserCache(User user) {
        log.debug("사용자 캐시 업데이트 - ID: {}", user.getId());
        return user;
    }
}

@Service
public class ProductCacheService {
    
    @Cacheable(value = "products", key = "#id")
    public Product findById(Long id) {
        return productRepository.findById(id).orElse(null);
    }
    
    @Cacheable(value = "products:by-category", key = "#categoryId")
    public List<Product> findByCategory(Long categoryId) {
        return productRepository.findByCategoryId(categoryId);
    }
    
    @Cacheable(value = "products:popular", key = "'top-' + #limit")
    public List<Product> findPopularProducts(int limit) {
        return productRepository.findPopularProducts(PageRequest.of(0, limit));
    }
    
    @CacheEvict(value = {"products", "products:by-category", "products:popular"}, key = "#product.id")
    public void evictProductCache(Product product) {
        log.debug("상품 캐시 무효화 - ID: {}", product.getId());
    }
    
    @CacheEvict(value = "products:by-category", key = "#categoryId")
    public void evictCategoryCache(Long categoryId) {
        log.debug("카테고리별 상품 캐시 무효화 - Category ID: {}", categoryId);
    }
    
    @CacheEvict(value = "products:popular", allEntries = true)
    public void evictPopularProductsCache() {
        log.debug("인기 상품 캐시 무효화");
    }
    
    // 배치 처리를 위한 캐시 워밍업
    @EventListener
    @Async
    public void handleProductCacheWarmup(ProductCacheWarmupEvent event) {
        log.info("상품 캐시 워밍업 시작");
        
        // 인기 상품 미리 로드
        findPopularProducts(20);
        
        // 주요 카테고리별 상품 미리 로드
        List<Long> majorCategories = Arrays.asList(1L, 2L, 3L, 4L, 5L);
        majorCategories.forEach(this::findByCategory);
        
        log.info("상품 캐시 워밍업 완료");
    }
}

@Service
public class OrderCacheService {
    
    @Cacheable(value = "orders", key = "#id")
    public Order findById(Long id) {
        return orderRepository.findById(id).orElse(null);
    }
    
    @Cacheable(value = "orders:by-user", key = "#userId")
    public List<Order> findByUserId(Long userId) {
        return orderRepository.findByUserId(userId);
    }
    
    @Cacheable(value = "orders:recent", key = "#userId + '_' + #limit")
    public List<Order> findRecentOrders(Long userId, int limit) {
        return orderRepository.findRecentByUserId(userId, PageRequest.of(0, limit));
    }
    
    @CacheEvict(value = {"orders", "orders:by-user", "orders:recent"}, key = "#order.id")
    public void evictOrderCache(Order order) {
        log.debug("주문 캐시 무효화 - ID: {}", order.getId());
    }
    
    @CacheEvict(value = {"orders:by-user", "orders:recent"}, key = "#userId")
    public void evictUserOrdersCache(Long userId) {
        log.debug("사용자 주문 캐시 무효화 - User ID: {}", userId);
    }
    
    @CachePut(value = "orders", key = "#order.id")
    public Order updateOrderCache(Order order) {
        log.debug("주문 캐시 업데이트 - ID: {}", order.getId());
        
        // 관련 사용자 주문 캐시도 무효화
        evictUserOrdersCache(order.getUser().getId());
        
        return order;
    }
}
```

## 6. 응집도 측정 도구와 기법

### 6.1 코드 분석 도구를 활용한 응집도 측정

```java
// SonarQube 규칙을 활용한 응집도 측정
// 1. 클래스 크기 제한
// 2. 메서드 복잡도 제한
// 3. 순환 복잡도 측정

@Component
@AnalyzedByQualityGate
public class HighCohesionExample {
    
    // LCOM (Lack of Cohesion in Methods) 측정
    // 낮은 LCOM 값 = 높은 응집도
    
    private final UserRepository userRepository;
    private final EmailService emailService;
    private final PasswordEncoder passwordEncoder;
    
    // 모든 메서드가 동일한 필드를 사용하므로 응집도가 높음
    public void createUser(CreateUserRequest request) {
        User user = buildUser(request);
        User savedUser = userRepository.save(user);
        emailService.sendWelcomeEmail(savedUser);
    }
    
    public User findUser(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
    }
    
    public void changePassword(Long userId, String newPassword) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        String encodedPassword = passwordEncoder.encode(newPassword);
        user.setPassword(encodedPassword);
        userRepository.save(user);
        
        emailService.sendPasswordChangeNotification(user);
    }
    
    private User buildUser(CreateUserRequest request) {
        return User.builder()
                .email(request.getEmail())
                .name(request.getName())
                .password(passwordEncoder.encode(request.getPassword()))
                .build();
    }
}
```

### 6.2 리팩토링 체크리스트

```java
// 응집도 개선을 위한 체크리스트

public class CohesionChecklist {
    
    /*
     * 1. 단일 책임 확인
     * - 클래스가 하나의 이유로만 변경되는가?
     * - 클래스명이 의도를 명확히 표현하는가?
     */
    
    /*
     * 2. 메서드 응집도 확인
     * - 메서드들이 동일한 데이터를 조작하는가?
     * - 메서드들이 동일한 목적을 가지고 있는가?
     */
    
    /*
     * 3. 데이터 응집도 확인
     * - 클래스의 모든 필드가 대부분의 메서드에서 사용되는가?
     * - 사용되지 않는 필드는 없는가?
     */
    
    /*
     * 4. 기능적 응집도 달성
     * - 각 메서드가 명확한 하나의 기능을 수행하는가?
     * - 부수 효과가 최소화되어 있는가?
     */
    
    /*
     * 5. 의존성 응집도 확인
     * - 의존성이 명확하고 필요한 것만 주입되는가?
     * - 순환 의존성이 없는가?
     */
}
```

## 결론

응집도 향상의 핵심 원칙:

1. **단일 책임 원칙**: 클래스와 메서드는 하나의 책임만 가져야 함
2. **관련성 극대화**: 함께 위치한 요소들은 밀접하게 관련되어야 함
3. **명확한 목적**: 각 구성 요소의 목적이 명확해야 함
4. **최소 의존성**: 불필요한 의존성은 제거해야 함
5. **지속적 리팩토링**: 시간이 지나며 응집도가 떨어지지 않도록 지속적으로 개선

높은 응집도를 가진 코드는 다음과 같은 이점을 제공합니다:
- 이해하기 쉬움
- 수정하기 쉬움
- 재사용하기 쉬움
- 테스트하기 쉬움
- 버그 발생률 감소

Spring 애플리케이션에서 응집도를 높이기 위해서는 DI를 적절히 활용하고, 레이어별로 명확한 책임을 부여하며, 도메인 중심의 설계를 통해 비즈니스 로직을 적절한 위치에 배치하는 것이 중요합니다.
